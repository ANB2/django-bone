#!/bin/bash
#
# Generates C "Object" Skeletons Simply and Properly
# Justine Tunney <jtunney@lobstertech.com>
# Licensed MIT
#

[ -z "$PROJ" ]     && PROJ=$1
[ -z "$NAME" ]     && NAME=$2
[ -z "$PROJ" ]     && ( echo "missing project name!" >&2; exit 1 )
[ -z "$NAME" ]     && ( echo "missing object name!" >&2; exit 1 )
[ -z "$EMAIL" ]    && EMAIL="$(git config user.email)"
[ -z "$EMAIL" ]    && EMAIL="$USER@$(hostname -f)"
[ -z "$AUTHOR" ]   && AUTHOR="$(git config user.name)"
[ -z "$AUTHOR" ]   && AUTHOR="$USER"
[ -z "$DESCRIP" ]  && DESCRIP="$PROJ"
[ -z "$LICENSE" ]  && LICENSE="GNU AGPL v3 or later"

PROJ_SYMBOL=$(echo $PROJ | tr a-z A-Z | tr - _)
NAME_SYMBOL=$(echo $NAME | tr a-z A-Z | tr - _)

echo "generating $NAME.h..."
cat >$NAME.h <<EOF
/*
 * $PROJ -- $DESCRIP
 * Copyright (c) $(date +%Y) $AUTHOR
 * Licensed $LICENSE
 */

/**
 * @file ${NAME}.h
 * @brief ${NAME} Object
 */

#ifndef ${PROJ_SYMBOL}_${NAME_SYMBOL}_H
#define ${PROJ_SYMBOL}_${NAME_SYMBOL}_H

#include <assert.h>

#define ${NAME_SYMBOL}_TOKEN 0xACAB

typedef struct ${NAME}_s ${NAME}_t;

struct ${NAME}_s {
    int token;              /**< ${NAME}_TOKEN if not destroyed */
    int refs;               /**< reference count of object */
};

/**
 * Allocates a $NAME object
 *
 * @return $NAME object or NULL or error.
 * @sa ${NAME}_unref(), ${NAME}_destroy()
 */
${NAME}_t *${NAME}_new();

/**
 * Frees resources associated with $NAME object
 *
 * Please call ${NAME}_unref() instead.
 *
 * @param $NAME  $NAME object
 * @sa ${NAME}_new()
 */
void ${NAME}_destroy(${NAME}_t *${NAME});

/**
 * Increase dictionary object reference count
 *
 * @param ${NAME}  ${NAME} object
 * @return  Pointer to same object or NULL on error.
 * @sa ${NAME}_unref()
 */
${NAME}_t *${NAME}_ref(${NAME}_t *${NAME});

/**
 * Decrease dictionary object reference count
 *
 * If ref count reaches zero, object will be freed immediately.
 *
 * @param ${NAME}  ${NAME} object
 * @return  Pointer to same object or NULL on error.
 * @sa ${NAME}_unref()
 */
int ${NAME}_unref(${NAME}_t *${NAME});

/**
 * Is your pointer valid?
 *
 * @param ${NAME}  ${NAME} object
 * @return  1 if NULL, 0 if good, crash if bad memory
 */
static inline int ${NAME}_badmem(${NAME}_t *${NAME})
{
    if (!${NAME})
        return true;
    if (*(int *)${NAME} != ${NAME_SYMBOL}_TOKEN)
        assert(!"memory error detected");
    return false;
}

#endif /* ${PROJ_SYMBOL}_${NAME_SYMBOL}_H */

/* For Emacs:
 * Local Variables:
 * indent-tabs-mode:nil
 * tab-width:4
 * c-basic-offset:4
 * c-file-style:nil
 * End:
 * For VIM:
 * vim:set expandtab softtabstop=4 shiftwidth=4 tabstop=4:
 */
EOF

echo "generating $NAME.c..."
cat >$NAME.c <<EOF
/*
 * $PROJ -- $DESCRIP
 * Copyright (c) $(date +%Y) $AUTHOR
 * Licensed $LICENSE
 */

/**
 * @file ${NAME}.c
 * @brief ${NAME} Object Implementation
 */

#include "${PROJ}_private.h"

${NAME}_t *${NAME}_new()
{
    ${NAME}_t *${NAME} = calloc(1, sizeof(${NAME}_t));
    ${NAME}->token = ${NAME_SYMBOL}_TOKEN;
    return ${NAME}_ref(${NAME});
}

void ${NAME}_destroy(${NAME}_t *${NAME})
{
    if (${NAME}_badmem(${NAME}))
        return;
    free(${NAME});
}

${NAME}_t *${NAME}_ref(${NAME}_t *${NAME})
{
    if (!${NAME}_badmem(${NAME})) {
        ${NAME}->refs++;
        return ${NAME};
    } else {
        return NULL;
    }
}

int ${NAME}_unref(${NAME}_t *${NAME})
{
    if (${NAME}_badmem(${NAME}))
        return 1;
    if (--${NAME}->refs == 0) {
        ${NAME}_destroy(${NAME});
        return 1;
    }
    return 0;
}

/* For Emacs:
 * Local Variables:
 * indent-tabs-mode:nil
 * tab-width:4
 * c-basic-offset:4
 * c-file-style:nil
 * End:
 * For VIM:
 * vim:set expandtab softtabstop=4 shiftwidth=4 tabstop=4:
 */
EOF
